!!!
%html
	%head
		%title Anthony Cameron
		%link{:rel => "stylesheet", :href => "css/all.min.css", :type => "text/css"}
		%link{:href => "//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css", :rel=>"stylesheet"}
		%meta{:name=>"viewport", :content=>"width=device-width,initial-scale=1"}
		%meta{:name=>"description", :content=>"Everything you need to know about Anthony Cameron: A collection of personal projects, featuring WebGL, GLSL shaders, JavaScript, C++.  A sample of my portfolio.  My resume.  My philosophy."}
		%meta{:name=>"author", :content=>"Anthony Cameron"}
		:plain

			<script id="perlin.frag" type="x-shader/x-fragment">
					#ifdef GL_ES
					precision highp float;
					#endif

					varying vec2 vTextureCoord;

					uniform sampler2D uperm_sampler;
					uniform sampler2D igrad_sampler;
					uniform float time;
					uniform float resX;
					uniform float resY;

					float fade(in float t)
					{
							return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
					}
					float perm(in float x)
					{
							return texture2D(uperm_sampler, vec2(x / 256.0, 0)).r * 256.0;
					}
					float grad(in float x, in vec3 p)
					{
							return dot(texture2D(igrad_sampler, vec2(x,0)).rgb, p);
					}
					float lerp(in float a, in float b, in float c)
					{
							return mix(a,b,c);
					}
					float inoise(vec3 p)
					{
							vec3 P = mod(floor(p), 256.0);
							p -= floor(p);
							vec3 f = vec3(fade(p.x), fade(p.y), fade(p.z));
							float A = perm(P.x) + P.y;
							float AA = perm(A) + P.z;
							float AB = perm(A + 1.0) + P.z;
							float B =  perm(P.x + 1.0) + P.y;
							float BA = perm(B) + P.z;
							float BB = perm(B + 1.0) + P.z;


							return lerp(
									lerp(lerp(grad(perm(AA), p),
											grad(perm(BA), p + vec3(-1.0, 0.0, 0.0)), f.x),
											lerp(grad(perm(AB), p + vec3(0.0, -1.0, 0.0)),
													grad(perm(BB), p + vec3(-1.0, -1.0, 0.0)), f.x), f.y),
									lerp(lerp(grad(perm(AA + 1.0), p + vec3(0.0, 0.0, -1.0)),
													grad(perm(BA + 1.0), p + vec3(-1.0, 0.0, -1.0)), f.x),
									lerp(grad(perm(AB + 1.0), p + vec3(0.0, -1.0, -1.0)),
											grad(perm(BB + 1.0), p + vec3(-1.0, -1.0, -1.0)), f.x), f.y),
							f.z);

					}

					float fbm(vec3 p){
						float f = 0.0;
						f += 0.5000*inoise(p); p*=2.02;
						f += 0.2500*inoise(p); p*=2.03;
						f += 0.1250*inoise(p); p*=2.01;
						f += 0.0625*inoise(p); p*=2.04;
						f /= 0.9375;
						return f;
					}

					void main(void) {
						float slowtime = 0.025 * time;
						vec2 q = gl_FragCoord.xy / vec2(resX,resY).xy;
						vec2 p = -1.0 + 2.0*q;
						p.x *= resX/resY;

						p /= 2.0; // effective zoom

						float u = p.x;
						float v = p.y;

						p.x -= 0.1;
						float r = sqrt( dot(p,p) );
						float a = atan( p.y, p.x );
						float noiseCoef = 0.1;
						for (float level = 1.0; level < 5.0; level ++)
						{
									noiseCoef = noiseCoef + (0.1 * level)
											* abs(inoise(
													vec3(level * u * 10.0,
															level * v * 10.0,
															time*0.75)));
						}

						float rednoise = 0.1;
						float xx = r;
						float yy = a;
						for (float level = 1.0; level < 5.0; level ++)
						{
									rednoise = rednoise + (0.078 * level)
											* abs(inoise(
													vec3(level * xx * 30.0,
															level * yy * 10.0,
															0.0)));
						}

						// calculate vein noise
						float veinnoise = 0.3;
						xx = r;
						yy = a;
						for (float level = 1.0; level < 3.0; level ++)
						{
									veinnoise = veinnoise + ((cos(time*0.25)*0.15 + 1.0) * 3.0 * level)
											* abs(inoise(
													vec3(level * xx * 15.0,
															level * yy * 10.0,
															0.15*time)));
						}

						// calculate nearly exactly same noise as vein noise, but a tiny bit off for specular highlight of vein
						vec2 hh = vec2(p.x+0.002, p.y-0.002);
						float rhh = sqrt( dot(hh,hh) );
						float ahh = atan( hh.y, hh.x );
						float veinnoise2 = 0.3;
						xx = rhh;
						yy = ahh;
						for (float level = 1.0; level < 3.0; level ++)
						{
									veinnoise2 = veinnoise2 + ((cos(time*0.25)*0.15 + 1.0) * 10.0 * level)
											* abs(inoise(
													vec3(level * xx * 15.0,
															level * yy * 10.0,
															0.15*time)));
						}



						vec3 sclera = vec3(0.9, 0.9, 0.9);
						vec3 color = vec3(0,0,0);
						float f = 1.0;
						if ( r < 0.85 ) {
							f = smoothstep( 0.842, 0.85, r);
							color = sclera;
							color = mix(color, vec3(0), f);

							// veins
							f = max(0.0, 1.0 - veinnoise);
							color = mix(color, vec3(1,0,0), 0.25*f);

							// specular highlight of vein
							f = max(0.0, 1.0 - veinnoise2);
							color = mix(color, vec3(1), f);

							// dull edges to black
							f = smoothstep( 0.45, 1.0, r);
							color = mix(color, vec3(0), f);

							// scelera texture
							f = rednoise;
							color = mix(color, vec3(0.10,0,0), 0.5*f);
						}
						if ( r < 0.39 ) {
							// base:
							vec3 blue = vec3(0.1,0.15,0.24);

							f = 1.0 - smoothstep( 0.36, 0.37, r);
							color = mix (color, blue, f);

							// background noise of iris
							if (r < 0.34) {
								color = mix (color, vec3(0.2, 0.2, 0.7), noiseCoef);
							}

							// secondary iris colour
							f = 1.0 - smoothstep( 0.0, 0.32, r);
							color = mix(color, vec3(1.0,0.4,0.2), 2.0*f*noiseCoef );

							// spindels
							f = fbm( vec3(12.0*r,15.0*a, slowtime * 4.0) );
							color = mix(color, vec3(1.0), f);

							// spindels
							a = slowtime*fbm(20.0*vec3(p.xy,1.0));
							f = fbm( vec3(20.0*r,23.0*a, slowtime * 4.0) );
							color = mix(color, vec3(1.0), f);

							// pupil
							float step = smoothstep(0.13,0.14,r);
							step = smoothstep(0.13 - slowtime*noiseCoef,0.14,r);  // creepy shit with this line on
							color *= step;
						}
						// specular highlight
						f = 1.0 - smoothstep( 0.0, 0.125, length(p - vec2(-0.2, 0.23)));
						color += vec3(1.0,0.9,0.8)*f;
						gl_FragColor = vec4(color.xyz, 1);
					}
			</script>
			<script id="perlin.vert" type="x-shader/x-vertex">
					attribute vec3 aVertexPosition;
					attribute vec2 aTextureCoord;

					uniform mat4 uMVMatrix;
					uniform mat4 uPMatrix;

					varying vec2 vTextureCoord;
					void main(void) {
							gl_Position = vec4(aVertexPosition, 1.0);
							vTextureCoord = aTextureCoord;
					}
			</script>
			<script type="text/javascript">
				window.requestAnimFrame = (function() {
					return window.requestAnimationFrame ||
								window.webkitRequestAnimationFrame ||
								window.mozRequestAnimationFrame ||
								window.oRequestAnimationFrame ||
								window.msRequestAnimationFrame ||
								function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
									window.setTimeout(callback, 1000/60);
								};
				})();

				var gl;
				var canvas;
				var shaderProgram;
				var p_perm;
				var p_gradient;
				var permutation = new Uint8Array([151,160,137,91,90,15,
					131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
					190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
					88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
					77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
					102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
					135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
					5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
					223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
					129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
					251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
					49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
					138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]);

				function initGL(canvas) {
					try {
						gl = canvas.getContext("experimental-webgl");
						gl.viewportWidth = canvas.width;
						gl.viewportHeight = canvas.height;
					} catch (e) {
						return -1;
					}
				}

				function getShader(gl, id) {
					var shaderScript = document.getElementById(id);
					if (!shaderScript) {
						return null;
					}

					var str = "";
					var k = shaderScript.firstChild;
					while (k) {
						if (k.nodeType == 3) {
							str += k.textContent;
						}
						k = k.nextSibling;
					}

					var shader;
					if (shaderScript.type == "x-shader/x-fragment") {
						shader = gl.createShader(gl.FRAGMENT_SHADER);
					} else if (shaderScript.type == "x-shader/x-vertex") {
						shader = gl.createShader(gl.VERTEX_SHADER);
					} else {
						return null;
					}

					gl.shaderSource(shader, str);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						alert(gl.getShaderInfoLog(shader));
						return null;
					}

					return shader;
				}

				function initShaders() {
					var fragmentShader = getShader(gl, "perlin.frag");
					var vertexShader = getShader(gl, "perlin.vert");

					shaderProgram = gl.createProgram();
					gl.attachShader(shaderProgram, vertexShader);
					gl.attachShader(shaderProgram, fragmentShader);
					gl.linkProgram(shaderProgram);

					if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
							alert("Could not initialise shaders");
					}

					gl.useProgram(shaderProgram);

					shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
					gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

					shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
					gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

					shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
					shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
					shaderProgram.perm_sampler = gl.getUniformLocation(shaderProgram, "uperm_sampler");
					shaderProgram.grad_sampler = gl.getUniformLocation(shaderProgram, "igrad_sampler");
					shaderProgram.time = gl.getUniformLocation(shaderProgram, "time");
					shaderProgram.resX = gl.getUniformLocation(shaderProgram, "resX");
					shaderProgram.resY = gl.getUniformLocation(shaderProgram, "resY");
				}


				function handleLoadedTexture(texture) {
						gl.bindTexture(gl.TEXTURE_2D, texture);
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.bindTexture(gl.TEXTURE_2D, null);
				}




				function initTexture() {
					p_perm = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, p_perm);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, 256, 1, 0, gl.LUMINANCE, gl.UNSIGNED_BYTE, permutation);
					var g = new Uint8Array([1,1,0,    -1,1,0,    1,-1,0,    -1,-1,0,
																	1,0,1,    -1,0,1,    1,0,-1,    -1,0,-1,
																	0,1,1,    0,-1,1,    0,1,-1,    0,-1,-1,
																	1,1,0,    0,-1,1,    -1,1,0,    0,-1,-1]);
					p_gradient = gl.createTexture();
					gl.bindTexture(gl.TEXTURE_2D, p_gradient);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, g);
				}

				var cubeVertexPositionBuffer;
				var cubeVertexTextureCoordBuffer;
				var cubeVertexIndexBuffer;

				function initBuffers() {
					cubeVertexPositionBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
					vertices = [
							// Back face
							-1.0, -1.0, -1.0,
							-1.0,  1.0, -1.0,
							1.0,  1.0, -1.0,
							1.0, -1.0, -1.0,
					];
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
					cubeVertexPositionBuffer.itemSize = 3;
					cubeVertexPositionBuffer.numItems = 4;

					cubeVertexTextureCoordBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					var textureCoords = [
						// Back face
						1.0, 0.0,
						1.0, 1.0,
						0.0, 1.0,
						0.0, 0.0,
					];
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
					cubeVertexTextureCoordBuffer.itemSize = 2;
					cubeVertexTextureCoordBuffer.numItems = 4;

					cubeVertexIndexBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
					var cubeVertexIndices = [
							0, 1, 2,      0, 2, 3,    // Back face
					];
					gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
					cubeVertexIndexBuffer.itemSize = 1;
					cubeVertexIndexBuffer.numItems = 6;
				}

				function resizeCanvas() {
					canvas.height = canvas.clientHeight;
					canvas.width = canvas.clientWidth;
				}

				function drawScene() {
					resizeCanvas();
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;

					gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
					gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

					gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, cubeVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, p_perm);
					gl.uniform1i(shaderProgram.perm_sampler, 0);
					gl.activeTexture(gl.TEXTURE1);
					gl.bindTexture(gl.TEXTURE_2D, p_gradient);
					gl.uniform1i(shaderProgram.grad_sampler, 1);

					gl.uniform1f(shaderProgram.time, TICK);
					gl.uniform1f(shaderProgram.resX, canvas.width);
					gl.uniform1f(shaderProgram.resY, canvas.height);

					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
					gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
				}

				var TICK = 0.0;
				function tick() {
					requestAnimFrame(tick);
					if (window.scrollY > 500) {
						TICK = 0;
						return;
					}
					drawScene();
					TICK += 0.02;
				}

				function webGLStart() {
					initGL(canvas);
					initShaders();
					initBuffers();
					initTexture();
					gl.clearColor(0.0, 0.0, 0.0, 1.0);
					tick();
				}

				document.addEventListener("DOMContentLoaded", function(event) {
					canvas = document.getElementById("c");
					gl = canvas.getContext("experimental-webgl");
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;
					webGLStart();
				});
			</script>
	%body
		.content
			%header.top-header
				.aligned-section
					.padded
						%ul
							%li
								%a.home{href: "#", title: "Home"}
									%i.fa.fa-home
							%li
								%a{:href=>"#lab"} Lab
							%li
								%a{:href=>"#portfolio"} Portfolio
							%li
								%a{:href=>"#philosophy"} Philosophy
							%li
								%a{:href=>"/resume.html"} Resume
							%li
								%a{:href=>"https://blog.echoplex.us", :target => "_blank"} Blog
			.splash-container.fixed
				.splash
					%canvas#c
			.splash-pusher
			%section#main
				#lab.readable-section
					.flashy-header
						%h1.readable-section-header e-laboratory
					%p.overview I like to make digital things.

					#echoplexus.project
						.images.images-right.images-40
							.slide
								%a{:href=>"img/echoplexus-latest.png", :target => "_blank"}
									%img{:src=>"img/echoplexus-latest.png", :alt=>"chat"}
								%div.annotation echoplexus running as Firefox App on ubuntu
							.slide
								%a{:href=>"img/echoplexus_chat.jpg", :target => "_blank"}
									%img{:src=>"img/echoplexus_chat.jpg", :alt=>"chat"}
								%div.annotation echoplexus used to be a lot darker!  It got a revamp in 2014 for greater appeal.
						.project-description
							%h3
								%a{:href=>"#echoplexus"} echoplexus
							%p.date 2 Feb, 2013
							%h4 The Goods
							%ul
								%li
									%a.iconal{:href => "http://echoplex.us", :title => "External link to echoplex.us", :target => "_blank"}
										echoplex.us homepage
										%i.icon.icon-external-link
								%li
									%a.iconal{:href => "http://chat.echoplex.us", :title => "External link to chat.echoplex.us", :target => "_blank"}
										chat.echoplex.us
										%i.icon.icon-external-link
								%li
									%a.iconal{:href => "https://github.com/qq99/echoplexus",  :title => "External link to the echoplexus project on github", :target => "_blank"}
										Code & Future
										%i.icon.icon-github
							%h4 What is it?
							%p Echoplexus is an anonymous, web-based, IRC-like chatting platform that makes its best effort to respect your privacy. It allows you to create public or private channels. You can encrypt your chats. You can secure a pseudonym for linkable anonymity. You can code and draw together in real time. You can make free and secure Peer2Peer video and voice calls with the people in your channel using WebRTC.
							%p
								For a full overview of all the features, please visit
								%a{href: "https://echoplex.us", target: "blank"} echoplex.us.
							%p The name echoplexus was mostly motivated by the song,
								%a.iconal{:href=> "https://www.youtube.com/watch?feature=player_detailpage&v=BJYpWVNvI5s", :title => "'Nine Inch Nails - Echoplex - Sacramento HD Multicam', Youtube", :target => "_blank"}
									Echoplex
									%i.icon.icon-external-link
								by Nine Inch Nails. Listen to it and you might get a feel for how I felt while testing this ;)
							%h4 Interested?
							%p
								I'd love it if you collaborated with us on
								%a.iconal{:href => "https://github.com/qq99/echoplexus",  :title => "External link to the echoplexus project on github", :target => "_blank"}
									github!
									%i.icon.icon-github
					#radio.project
						.images.images-right.images-50
							.slide
								%a{:href=>"img/radio.jpg", :target=>"_blank"}
									%img{:src=>"img/radio.jpg"}
								%div.annotation Not entirely practical, but it looks pretty :)
						.project-description
							%h3
								%a{:href=>"#radio"} radio
							%p.date 2 Feb, 2013
							%h4 The Goods
							%ul
								%li
									%a{:href=>"http://radio.anthonycameron.com", :title => "radio.anthonycameron.com", :target=>"_blank"} radio.anthonycameron.com
							%h4 Why bother?
							%p I had this idea to share my favourite songs to introduce others to my specific taste without having to rely on dozens of youtube/grooveshark links, so I created this in <1 day.  It's just a simple sinatra app that scrapes the /music/ directory and writes the paths into an array, which was preferable for speed of development.  It kinda sucks, especially when attempting to select a song with a tablet, but it gets the job done.
							%p MP3 isn't widely supported and I sure wasn't about to convert my audio to different formats for this one-off project; unfortunately all my Radiohead is in FLAC format.
							%p Featuring:
							%ul
								%li
									Some sweet player icons from
									%a.iconal{:href => "http://fortawesome.github.com/Font-Awesome/", :title => "External link to the fontawesome project", :target => "_blank"}
										fontawesome
										%i.icon.icon-external-link
										%i.icon.icon-github
								%li Mouse wheel controls
								%li Some 3D CSS transformations
								%li Some of my favourite songs (of those that exist in MP3 format)
								%li HTML5 audio
							%p So, if ever you asked, "What kind of music does this guy listen to?", now you know.
					#webglBackgroundBumps.project
						.images.images-left.images-40
							.slide
								%a{:href=>"/lab/background-bumps"}
									%img{:src=>"img/background-bumps.jpg"}
								%div.annotation Generally: the subtler the pattern, the better the result
							.slide
								%a{:href=>"/lab/background-bumps"}
									%img{:src=>"img/background-bumps2.jpg"}
						.project-description
							%h3
								%a{:href=>"#webglBackgroundBumps"} WebGL Background Bump Mapping
							%p.date 12 May, 2012
							%h4 The Goods
							%ul
								%li
									%a{:href=>"/lab/background-bumps"} Demo
								%li
									%a{:href=>"/lab/background-bumps"} Documentation
							%h4 What is it?
							%p Background textures have always been fairly flat and static things.  I set out to increase their (apparent) depth.
							%p It's not entirely practical, and in retrospect I'm not sure why I created it, but here it is!  I think it's kind of neat and kind of pretty.
							%p This project features WebGL, bump mapping, and the Phong reflection model to 'enhance' a website's background.  I don't particularly recommend anyone to use it in any kind of production site at this time (like most of WebGL).
					#webglSRPG.project
						.images.images-left.images-40
							.slide
								%a{:href=>"img/1.png"}
									%img{:src=>"img/1.png"}
							.slide
								%a{:href=>"img/2.png"}
									%img{:src=>"img/2.png"}
							.slide
								%a{:href=>"img/3.png"}
									%img{:src=>"img/3.png"}
							.slide
								%a{:href=>"img/4.png"}
									%img{:src=>"img/4.png"}
						.project-description
							%h3
								%a{:href=>"#webglSRPG"} WebGL Strategy RPG Engine
							%p.date 5 Dec, 2011
							%h4 The Goods
							%ul
								%li
									%a{:href=>"cs488f2011project/app/", :target=>"_blank"} Demo
								%li
									%a{:href=>"cs488f2011project/", :target=>"_blank"} Technical & User Manual
								%li
									%a.iconal{:href=>"https://github.com/qq99/WebGL_SRPG", :target=>"_blank"}
										Code
										%i.icon.icon-github
							%h4 Executive Summary
							%p
								Created for CS488 (Introduction to Computer Graphics) during Fall 2011 at the University of Waterloo as a final project.  This marks the second
								time that I've taken this course.  Against all odds, I somehow managed to miss the exam during my first course attempt, and was assigned a Fail outright.  I'm pleased to announce
								that I have since passed this wonderfully fun course!
							%p
								The focus was on procedural generation, completely framework free code.  It was primarily an exploration in real-time interactive graphics, utilizing only shaders and
								modern graphics techniques.
							%p
								I did not meet all of the objectives I set for myself, but I was able to explore: texture mapping, texture atlasing, bump mapping, procedural terrain, water reflections,
								animations using Catmull-Rom splines, Phong shading/lighting model, WebGL, OpenGL ES 2.0, AI pathfinding, Perlin noise, and context-free trees.
							%p
								When I get the time, I'd like to explore more of the objectives I wasn't able to achieve, probably separate from this project.  I've put in a bit of work to polish
								certain aspects (namely, the character animation and interleaving the terrain data), but haven't had time to commit the changes yet.
					#perlinshader.project
						.images.images-left.images-40
							.slide
								%a{:href=>"experiments/perlinshader/shader1.html", :target=>"_blank"}
									%img{:src=>"img/shader1.jpg"}
								%div.annotation
									Multi-function scene
							.slide
								%a{:href=>"experiments/perlinshader/oncube.html", :target=>"_blank"}
									%img{:src=>"img/shadercube.jpg"}
								%div.annotation
									Mapped onto a spinning cube
							.slide
								%a{:href=>"experiments/perlinshader/shader2.html", :target=>"_blank"}
									%img{:src=>"img/shader2.jpg"}
								%div.annotation
									Perlin's standard turbulence
							.slide
								%a{:href=>"experiments/perlinshader/shader3.html", :target=>"_blank"}
									%img{:src=>"img/shader3.jpg"}
								%div.annotation
									Oscillator
							.slide
								%a{:href=>"experiments/perlinshader/shader4.html", :target=>"_blank"}
									%img{:src=>"img/shader4.png"}
								%div.annotation
									Toon shaded / ghetto heat map

							.slide
								%a{:href=>"experiments/perlin/", :target=>"_blank"}
									%img{:src=>"img/perlin1.jpg"}
								%div.annotation
									Version 1
							.slide
								%a{:href=>"experiments/perlin/", :target=>"_blank"}
									%img{:src=>"img/perlin2.jpg"}
							.slide
								%a{:href=>"experiments/perlin/", :target=>"_blank"}
									%img{:src=>"img/perlin3.jpg"}
						.project-description
							%h3
								%a{:href=>"#perlinshader"} Animating Functions of Improved 3D Perlin noise
							%p.date 27 Oct, 2011 &ndash; a sleepless night
							%h4 Demos
							%ul
								%li
									%a{:href=>"experiments/perlinshader/shader1.html", :target=>"_blank"} Multi-function
								%li
									%a{:href=>"experiments/perlinshader/oncube.html", :target=>"_blank"} Mapped onto a cube
								%li
									%a{:href=>"experiments/perlinshader/shader2.html", :target=>"_blank"} Perlin's standard turbulence
								%li
									%a{:href=>"experiments/perlinshader/shader3.html", :target=>"_blank"} Oscillator
								%li
									%a{:href=>"experiments/perlinshader/shader4.html", :target=>"_blank"} toon shaded / ghetto heat map
							%h4 Overview
							%p
								:plain
									In this experiment, I made a quick port of Ken Perlin's <a href="http://mrl.nyu.edu/~perlin/noise/" target="_blank">classical noise</a> in 3 dimensions.
									Due to its continuity properties, we can take a 2D cross-section and step through the 3<sup>rd</sup> dimension in time.  The end result is a continuous animation.
							%h4 Technical Overview
							%p
								After reading some of Perlin's work, namely some of his early SIGGRAPH slides, I became intrigued with the potential this has for both 3D texturing and the animation
								of 2D textures.  Many of these 2D textures, when animated, can produce some very compelling effects.  In this <a href="experiments/perlin/" target="_blank"> early demo page</a>
								I show one example of something that looks like the activity of the planet Jupiter.
							%p
								I employ fragment shaders to calculate per-pixel Perlin noise.  Geometry is minimal, consisting of only 2 triangles that are un-transformed.  Texture co-ordinates are generated and used in some animations, but for others only Fragment.xy is used.  In all cases, time is used as an index to the Z plane of the 3D noise.
							%h4 Benchmarks & Comparisons
							%p
								All I can say is: Wow.  WebGL (or more accurately, GLSL) fragment shaders are a huge step up in terms of performance when we compare to
								%a{:href=>"experiments/perlin/", :target=>"_blank"} my old CPU implementation.

							%p In the old implementation, on a 1GHz machine:
							%ul
								%li
									Firefox 7 would fail to achieve >30FPS on a 128x128 square.
								%li
									Chrome 15 seemed to achieve >30FPS, or if not, the visual stutter wasn't too noticeable.
							%p In the WebGL shader implementation, on a 1GHz machine:
							%ul
								%li
									Firefox 7 easily seems to acheive >30FPS on a 1680x945 rectangle.
								%li
									As it did for the old implementation, Chrome 15 seems to outshine Firefox again.
								%li
									Furthermore, both browsers can render arbitrary transforms (the texture mapped cube) of the noise, which is something that I would have considered impossible for real-time in the old implementation.
							%p
								How do we account for the speed improvements?  I would estimate that 99% of it is due to the change from CPU to GPU shaders; programming a highly parallelizable task on the GPU will naturally outperform its corresponding CPU-only implementation.  Moreover, the computation of Perlin noise is relatively simple, which makes it a good fit for approximation on the GPU.  I hypothesize that less JavaScript being employed might account for some of the speed improvement.
							%h4 Musings
							%p
								It was very tempting to use the "multi-function" noise as the background "image" for the Lab page.  However, after trying it out (and it looks beautiful) I deduced that I couldn't do this in complete faith, since WebGL is still somewhat sketchy; I experienced >4 Nvidia driver crashes, leading to complete browser failure.  Interestingly, it also crashed my Photoshop (and so assumably any other program using your GPU extensively).  It was either gamble with the value of my visitors' work or use a screenshot, and I think I made the better final choice.
							%p
								So, where does this leave us?  I now have a useful tool that will allow me to explore various noise patterns from within the browser; no need to attempt compiling an application that will then compile the shaders.  No need for a ton of external dependencies; just download the page, edit the shaders at the top of the source, and run!  This should hopefully allow me to explore new types of noise with ease.
							%p
								Additionally, WebGL would seem to be a fairly good reduced-power environment.  That is to say, we can expect the shaders to perform faster if they were used in a native C++ program, for example.
							%p
								Finally, those who want to learn more about shaders or procedural art might find looking at my code to be of some use.  I've set up the sample pages in such a way that they should resize to fill your browser window completely.  As such, if you go to full-screen mode (F11 key in most browsers), you can take a screenshot or save a perfect-fit wallpaper quite easily!
							%h4 Resources
							%ul
								%li
									%a{:href=>"http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter26.html", :target=>"_blank"} Implementing Improved Perlin Noise (GPU Gems, by S Green)
								%li
									%a{:href=>"http://http.developer.nvidia.com/GPUGems/gpugems_ch05.html", :target=>"_blank"} Implementing Improved Perlin Noise (GPU Gems, by K Perlin)
								%li
									%a{:href=>"http://learningwebgl.com/blog/?p=507", :target=>"_blank"} Learning WebGL &ndash; Lesson 5
					#cs488project.project
						.images.images-right.images-50
							.slide
								%a{:href=>"https://plus.google.com/photos/+AnthonyCamerona/albums/5631455218906031857", :target=>"_blank"}
									%img{:src=>"img/rt.jpg"}
						.project-description
							%h3
								%a{:href=>"#cs488project"}
									A ray-tracer with a focus on various material properties
							%p.date 26 Jul, 2011
							%h4 The Goods
							%ul
								%li
									%a{:href=>"cs488project/", :target=>"_blank"} Documentation
								%li
									%a{:href=>"cs488project/#gallery", :target=>"_blank"} Gallery
							%h4 Executive Summary
							%p Created for CS488 (Introduction to Computer Graphics) during Summer 2011 at the University of Waterloo as a final project.  Math in action.
							%p Render time: Approximately 2 minutes each.

				#portfolio.readable-section
					.flashy-header
						%h1.readable-section-header Portolio
					%p.overview Some things I worked on while freelancing.
					%div
						.images.images-right.images-30
							.slide
								%img{:src=>"img/portfolio/tile_ab.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_hannah.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_hklane.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_jerome.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_visum.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_shirtsbyme.jpg", :width=>"350", :height=>"350"}
						.images.images-right.images-30
							.slide
								%img{:src=>"img/portfolio/tile_solage_mobile.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_solage.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_solhotel.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_apwan.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_jwilliams.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_pd.jpg", :width=>"350", :height=>"350"}
							.slide
								%img{:src=>"img/portfolio/tile_e52.jpg", :width=>"350", :height=>"350"}
						.description
							%h2 Front-end Work
							%p I specialize in front-end development, and I believe I can make any design a reality.  I'm not a designer by trade, but I like to dabble and design via CSS.
							%p
								For many of these projects, I was the sole developer.  For a few, I worked with my good friend and colleague
								%a{:href=>"http://kaizhiwei.com", :target=>"_blank"} Kaizhi Wei
							%p Generally, the main focus was PSD2HTML.  Some were flat sites, others were driven by WordPress.  I used HAML and SASS were used for rapid prototyping, and image spritesheets whenever applicable.
							%p Many sites had needed custom widgets.  I've coded dozens of custom slideshows in my time, interactive maps, and several full-spread responsive image-based landing pages.
							%p I'm experienced with integration of external services &ndash; yelp, Facebook, iHomeFinder, and other 3rd party weather services.
							%p These days, I've fleshed out more in terms of back-end development.  I'd still consider myself primarily a front-end developer, as I'd say that's where the majority of my talents lie.  There's just something so satisfying about seeing things come to life in front of your eyes!

				#philosophy.readable-section
					.flashy-header
						%h1.readable-section-header Philosophy
					%p.overview Musings, really.
					.wall-of-text
						%p I don't want to hear, "philosophy is useless".
						%p I favour determinism, and that given the initial state and a set of rules, we could compute the entire state history of the universe. This is impossible from within the universe we wish to simulate. That is to say, I believe the universe can be described by a relatively compressed closed form system, whilst our everday happenings are just emergent phenomena of the decompression and computation of the system.  I believe this entails there is no such thing as free will, and this brings me peace.
						%p My ultimate academic goal is to understand myself and my environment. This will be a never ending quest that I very much look forward to. My applied goal is to create a computational intelligence. By this, I think I mean hard Artificial Intelligence. I want to create a machine that actually thinks, rather than gives the appearance of thinking.  I think that the term "AI" in popular vernacular doesn't describe this concept well at all.
						%p Ultimately, my ultimate academic goal is very likely impossible within my lifetime, barring future events drastically increasing my life expectancy.  I love the idea of a technological singularity, but fear that it's perhaps an egotistical creation of Humankind.  In a way, I look at it as the greatest romance we can bestow upon ourselves.  I want to live in a world where I don't feel like I'm constantly struggling in my interactions with computers.
						%p I'd describe my moral outlook as, "If it isn't hurting anybody, let them do it". I'm a bit of a moral utilitarian in the sense that I'm all for breaking laws if we can accelerate technological progress.
						%h2 Data
						%p Data munging is perhaps the biggest waste of time in our field.  If we cannot accomplish real computational intelligence, it would at least be nice to have "knowledge engines" come into being.  By these, I mean systems that can store facts, types, and relations and make basic inferences and convey the probability of correctness of those inferences.  I'd love to work on an ontology based system.
						%p I'm highly interested in compression and procedurally generated content. I feel like the two go hand-in-hand in a lot of respects. To me, there's something very elegant about being able to compress some information into it's minimum representation. We could store the contents of a signal in its "entirety" discretely (barring resolution issues), but I find it much more amazing to describe it succinctly with mathematics.
						%p For example, we could list all the points of a line or curve on a certain interval (requiring storage proportional to the size of the interval), or we can use a closed form expression (requiring constant storage independent of the size of interval) to save space at the cost of future computational resources to decompress it. This ties in with procedurally generated content, with which I'm sure the universe is such a system.  In this sense, I feel like there's a vague time<->space tradeoff that can be made: a certain feeling of "equivalent exchange" with regards to computation.
						%h2 Distributed Systems
						%p I enjoy distributed systems and feel that they are the future of personal computing. I believe information of all kinds should be free (which is oddly at ends with my ideals of privacy), and the added redundancy of information that a global distributed system would add would ensure no government could ever completely censor its citizens. Ideally, web sites should not be stored by just one person but by all the users who visit them.
						%h2 Security and Privacy
						%p Security is a huge focus of mine, and I try hard to ensure that the users of my software aren't entering into any malicious clauses nor are they compromising themselves under false pretenses of security.
						%p How can data freedom coexist with privacy?  If we could eliminate greed as a motivator, and ensure peaceful acceptance of others, we wouldn't really have any need for privacy.  One would be able to air all kinds of embarassing and terrible moments and emotions if there were no fear of judgment or negative repercussions.  I don't think we can accomplish that.
						%p I feel anonymity will be necessary to further the evolution of our species. I don't think that we should consider only people as beings that holds rights, but instead extend these rights to information themselves. Ideas can certainly seem to come alive, replicate themselves, and infect the minds of others. I think that biological definitions of "life" and "alive" are missing the mark.
			%footer.bottom-footer
				.aligned-section
					.padded
						%ul.icons
							%li
								%a.iconal.external.different-context{:href=>"https://github.com/qq99", :title => "Github", :target => "_blank"}
									%i.fa.fa-github
							%li
								%a.iconal.external.different-context{:href=>"http://codepen.io/qq99", :title => "CodePen", :target => "_blank"}
									%i.fa.fa-codepen
							%li
								%a.iconal.external.different-context{:href=>"https://twitter.com/dontqq", :title => "Twitter", :target => "_blank"}
									%i.fa.fa-twitter
							%li
								%a.iconal.external.different-context{:href=>"http://ca.linkedin.com/in/anthonycameron/", :title => "LinkedIn", :target => "_blank"}
									%i.fa.fa-linkedin
		.scripts
			:plain
				<script type="text/javascript">
					var _gaq = _gaq || [];
					_gaq.push(['_setAccount', 'UA-26321085-1']);
					_gaq.push(['_trackPageview']);

					(function() {
						var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
						ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
						var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
					})();
				</script>
